% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/families.R
\name{mvgam_families}
\alias{mvgam_families}
\alias{tweedie}
\alias{student_t}
\alias{nmix}
\title{Supported mvgam families}
\usage{
tweedie(link = "log")

student_t(link = "identity")

nmix(link = "log")
}
\arguments{
\item{link}{a specification for the family link function. At present these cannot
be changed}
}
\description{
Supported mvgam families
}
\details{
\code{mvgam} currently supports the following standard observation families:
\itemize{
\item \code{\link[stats]{gaussian}} with identity link, for real-valued data
\item \code{\link[stats]{poisson}} with log-link, for count data
\item \code{\link[stats]{Gamma}} with log-link, for non-negative real-valued data
\item \code{\link[stats]{binomial}} with logit-link, for count data when the number
of trials is known (and must be supplied)
}

In addition, the following extended families from the \code{mgcv} and \code{brms} packages are supported:
\itemize{
\item \code{\link[mgcv]{betar}} with logit-link, for proportional data on \verb{(0,1)}
\item \code{\link[mgcv]{nb}} with log-link, for count data
\item \code{\link[brms]{lognormal}} with identity-link, for non-negative real-valued data
\item \code{\link[brms]{bernoulli}} with logit-link, for binary data
}

Finally, \code{mvgam} supports the three extended families described here:
\itemize{
\item \code{tweedie} with log-link, for count data (power parameter \code{p} fixed at \code{1.5})
\item \code{student_t()} (or \code{\link[brms]{student}}) with identity-link, for real-valued data
\item \code{nmix} for count data with imperfect detection modeled via a
State-Space N-Mixture model. The latent states are Poisson (with log link), capturing the 'true' latent
abundance, while the observation process is Binomial to account for imperfect detection. The
observation \code{formula} in these models is used to set up a linear predictor for the detection
probability (with logit link). See the example below for a more detailed worked explanation
of the \code{nmix()} family
}
Only \code{poisson()}, \code{nb()}, and \code{tweedie()} are available if
using \code{JAGS}. All families, apart from \code{tweedie()}, are supported if
using \code{Stan}.

Note that currently it is not possible to change the default link
functions in \code{mvgam}, so any call to change these will be silently ignored
}
\examples{
\donttest{
# An N-mixture example using family nmix()
# Simulate data from a Poisson-Binomial N-Mixture model
# True abundance is predicted by a single nonlinear function of temperature
# as well as a nonlinear long-term trend (as a Gaussian Process function)
set.seed(123)
gamdat <- gamSim(n = 80); N <- NROW(gamdat)
abund_linpred <- gamdat$y; temperature <- gamdat$x2

# A function to simulate from a squared exponential Gaussian Process
sim_gp = function(N, c, alpha, rho){
  Sigma <- alpha ^ 2 *
           exp(-0.5 * ((outer(1:N, 1:N, "-") / rho) ^ 2)) +
           diag(1e-9, N)
 c + mgcv::rmvn(1,
                mu = rep(0, N),
                V = Sigma)
}
trend <- sim_gp(alpha = 3,
                rho = 16,
                c = 0,
                N = N)
true_abund <- floor(10 + abund_linpred + trend)

# Detection probability increases linearly with decreasing rainfall
rainfall <- rnorm(N)
detect_linpred <- 0.4 + -0.55 * rainfall
detect_prob <- plogis(detect_linpred)

# Simulate observed counts
obs_abund <- rbinom(N, size = true_abund, prob = detect_prob)

# Plot true and observed time series
plot(true_abund,
     type = 'l',
     ylab = 'Abundance',
     xlab = 'Time',
     ylim = c(0, max(true_abund)),
     bty = 'l',
     lwd = 2)
lines(obs_abund, col = 'darkred', lwd = 2)
title(main = 'True = black; observed = red')

# Gather data into a dataframe suitable for mvgam modelling;
# This will require a 'cap' variable specifying the maximum K to marginalise
# over when estimating latent abundance (it does NOT have to be a fixed value)
model_dat <- data.frame(obs_abund,
                        temperature,
                        rainfall,
                        cap = max(obs_abund) + 20,
                        time = 1:N,
                        series = as.factor('series1'))

# Training and testing folds
data_train <- model_dat \%>\% dplyr::filter(time <= 74)
data_test <- model_dat \%>\% dplyr::filter(time > 74)

# Fit a model with informative priors on the two intercept parameters
# and on the length scale of the GP temporal trend parameter
# Note that the 'trend_formula' applies to the latent count process
# (a Poisson process with log-link), while the 'formula' applies to the
# detection probability (logit link)
mod <- mvgam(formula = obs_abund ~ rainfall,
             trend_formula = ~ s(temperature, k = 5) +
               gp(time, k = 10, c = 5/4, scale = FALSE),
             family = nmix(),
             data = data_train,
             newdata = data_test,
             priors = c(prior(std_normal(), class = '(Intercept)'),
                        prior(normal(2, 2), class = '(Intercept)_trend'),
                        prior(normal(15, 5), class = 'rho_gp_trend(time)')))

# Model summary and diagnostics
summary(mod)
plot(mod, type = 'residuals')

# Intercept parameters
mcmc_plot(mod,
          variable = "Intercept",
          regex = TRUE,
          type = 'hist')

# Hindcasts and forecasts of latent abundance (with truth overlain)
fc <- forecast(mod, type = 'latent_N')
plot(fc); points(true_abund, pch = 16, cex = 0.8)

# Latent abundance predictions are restricted based on 'cap'
max(model_dat$cap); range(fc$forecasts[[1]])

# Hindcasts and forecasts of detection probability (with truth overlain)
fc <- forecast(mod, type = 'detection')
plot(fc); points(detect_prob, pch = 16, cex = 0.8)

# Hindcasts and forecasts of observations
# (after accounting for detection error)
fc <- forecast(mod, type = 'response')
plot(fc)

# Hindcasts and forecasts of response expectations
# (with truth overlain)
fc <- forecast(object = mod, type = 'expected')
plot(fc); points(detect_prob * true_abund, pch = 16, cex = 0.8)

# Plot conditional effects
library(ggplot2)

# Effects on true abundance can be visualised using type = 'link'
abund_plots <- plot(conditional_effects(mod,
                                        type = 'link',
                                        effects = c('temperature', 'time')),
                    plot = FALSE)

# Effect of temperature on abundance
abund_plots[[1]] +
  ylab('Latent abundance')

# Long-term trend in abundance
abund_plots[[2]] +
  ylab('Latent abundance')

# Effect of rainfall on detection probability
det_plot <- plot(conditional_effects(mod,
                                     type = 'detection',
                                     effects = 'rainfall'),
                 plot = FALSE)
det_plot[[1]] +
  ylab('Pr(detection)')

# More targeted plots can use marginaleffects capabilities;
# Here visualise how response predictions might change
# if we considered different possible 'cap' limits on latent
# abundance and different rainfall measurements
plot_predictions(mod, condition = list('temperature',
                                       cap = c(15, 20, 40),
                                       rainfall = c(-1, 1)),
                type = 'response',
                conf_level = 0.5) +
 ylab('Observed abundance') +
 theme_classic()

# Example showcasing how cbind() is needed for Binomial observations
# Simulate two time series of Binomial trials
trials <- sample(c(20:25), 50, replace = TRUE)
x <- rnorm(50)
detprob1 <- plogis(-0.5 + 0.9*x)
detprob2 <- plogis(-0.1 -0.7*x)
dat <- rbind(data.frame(y = rbinom(n = 50, size = trials, prob = detprob1),
                        time = 1:50,
                        series = 'series1',
                        x = x,
                        ntrials = trials),
             data.frame(y = rbinom(n = 50, size = trials, prob = detprob2),
                        time = 1:50,
                        series = 'series2',
                        x = x,
                        ntrials = trials))
dat <- dplyr::mutate(dat, series = as.factor(series))
dat <- dplyr::arrange(dat, time, series)

# Fit a model using the binomial() family; must specify observations
# and number of trials in the cbind() wrapper
mod <- mvgam(cbind(y, ntrials) ~ series + s(x, by = series),
             family = binomial(),
             data = dat)
summary(mod)

}
}
\author{
Nicholas J Clark
}
