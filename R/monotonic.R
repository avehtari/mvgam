#' Monotonic splines in mvgam
#'
#' Uses constructors from package \pkg{splines2} to build monotonically increasing
#' or decreasing splines. Details also in Wang & Yan (2021).
#'
#' @inheritParams mgcv::smooth.construct.bs.smooth.spec
#' @param object A smooth specification object, usually generated by a term
#' `s(x, bs = "moi", ...)` or `s(x, bs = "mod", ...)`
#'
#' @details The constructor is not normally called directly,
#' but is rather used internally by [mvgam]. If they are not supplied then the
#' knots of the spline are placed evenly throughout the covariate values to
#' which the term refers: For example, if fitting 101 data with an 11
#' knot spline of x then there would be a knot at every 10th (ordered) x value.
#' The spline is an implementation of the closed-form I-spline basis based
#' on the recursion formula given by Ramsay (1988), in which the basis coefficients
#' must be constrained to either be non-negative (for monotonically increasing
#' functions) or non-positive (monotonically decreasing)
#' \cr
#' \cr
#' Take note that when using either monotonic basis, the number of basis functions
#' `k` must be supplied as an even integer due to the manner in
#' which monotonic basis functions are constructed
#'
#' @return An object of class `"moi.smooth"` or `"mod.smooth"`. In addition to
#' the usual elements of a smooth class documented under \code{\link[mgcv]{smooth.construct}},
#' this object will contain a slot called `boundary` that defines the endpoints beyond
#' which the spline will begin extrapolating (extrapolation is flat due to the first
#' order penalty placed on the smooth function)
#'
#' @note This constructor will result in a valid smooth if using a call to
#' \code{\link[mgcv]{gam}} or \code{\link[mgcv]{bam}}, however the resulting
#' functions will not be guaranteed to be monotonic because constraints on
#' basis coefficients will not be enforced
#'
#' @references
#' Wang, Wenjie, and Jun Yan. "Shape-Restricted Regression Splines with R Package splines2."
#' Journal of Data Science 19.3 (2021).
#' \cr
#' \cr
#' Ramsay, J. O. (1988). Monotone regression splines in action. Statistical Science, 3(4), 425--441.
#' @importFrom mgcv smooth.construct
#' @export
#' @author Nicholas J Clark
#' @name monotonic
#' @examples
#' \donttest{
#' # Simulate data from a monotonically increasing function
#' set.seed(123123)
#' x <- runif(80) * 4 - 1
#' x <- sort(x)
#' f <- exp(4 * x) / (1 + exp(4 * x))
#' y <- f + rnorm(80) * 0.1
#' plot(x, y)
#'
#' # A standard TRPS smooth doesn't capture monotonicity
#' library(mgcv)
#' mod_data <- data.frame(y = y, x = x)
#' mod <- gam(y ~ s(x, k = 16),
#'            data = mod_data,
#'            family = gaussian())
#'
#' library(marginaleffects)
#' plot_predictions(mod,
#'                  by = 'x',
#'                  newdata = data.frame(x = seq(min(x) - 0.5,
#'                                               max(x) + 0.5,
#'                                               length.out = 100)),
#'                  points = 0.5)
#'
#' # Using the 'moi' basis in mvgam rectifies this
#' mod_data$time <- 1:NROW(mod_data)
#' mod2 <- mvgam(y ~ s(x, bs = 'moi', k = 18),
#'              data = mod_data,
#'              family = gaussian(),
#'              chains = 2)
#'
#' plot_predictions(mod2,
#'                  by = 'x',
#'                  newdata = data.frame(x = seq(min(x) - 0.5,
#'                                               max(x) + 0.5,
#'                                               length.out = 100)),
#'                  points = 0.5)
#'
#' plot(mod2, type = 'smooth', realisations = TRUE)
#'
#' # 'by' terms that produce a different smooth for each level of the 'by'
#' # factor are also allowed
#' set.seed(123123)
#' x <- runif(80) * 4 - 1
#' x <- sort(x)
#'
#' # Two different monotonic smooths, one for each factor level
#' f <- exp(4 * x) / (1 + exp(4 * x))
#' f2 <- exp(3.5 * x) / (1 + exp(3 * x))
#' fac <- c(rep('a', 80), rep('b', 80))
#' y <- c(f + rnorm(80) * 0.1,
#'        f2 + rnorm(80) * 0.2)
#' plot(x, y[1:80])
#' plot(x, y[81:160])
#'
#' # Gather all data into a data.frame, including the factor 'by' variable
#' mod_data <- data.frame(y, x, fac = as.factor(fac))
#' mod_data$time <- 1:NROW(mod_data)
#'
#' # Fit a model with different smooths per factor level
#' mod <- mvgam(y ~ s(x, bs = 'moi', by = fac, k = 8),
#'              data = mod_data,
#'              family = gaussian(),
#'              chains = 2)
#'
#' # Visualise the different monotonic functions
#' plot_predictions(mod, condition = c('x', 'fac', 'fac'),
#'                  points = 0.5)
#' plot(mod, type = 'smooth', realisations = TRUE)
#'
#' # First derivatives (on the link scale) should never be
#' # negative for either factor level
#' (derivs <- slopes(mod, variables = 'x',
#'                  by = c('x', 'fac'),
#'                  type = 'link'))
#' all(derivs$estimate > 0)
#' }
smooth.construct.moi.smooth.spec <- function(object, data, knots){

  insight::check_if_installed("splines2")

  # Check arguments
  object$p.order <- 1
  if(object$bs.dim < 0)
    object$bs.dim <- 10
  `k(bs = 'moi')` <- object$bs.dim
  if(`k(bs = 'moi')` <= 1)
    stop("Basis dimension is too small",
         call. = FALSE)
  validate_pos_integer(`k(bs = 'moi')`)
  validate_even(`k(bs = 'moi')`)

  # Number of knots must be k / 2
  nk <- object$bs.dim / 2L

  if(!is.null(object$id))
    stop("Monotonic splines don't work with ids",
         call. = FALSE)

  # Check basis dimension
  if(length(object$term) != 1)
    stop("Monotonic basis only handles 1D smooths",
         call. = FALSE)

  # Find the data and specified knots
  x <- data[[object$term]]
  k <- knots[[object$term]]
  if(length(unique(x)) < nk)
    warning("basis dimension is larger than number of unique covariates")

  # Checks on knots
  if(is.null(k)) {
    xl <- min(x); xu <- max(x)
  } else {
    xl <- min(k); xu <- max(k);
    if(xl > min(x) || xu < max(x))
      stop("knot range does not include data",
           call. = FALSE)
    if(length(k) != nk)
      stop(paste("there should be ", nk - 1, " supplied knots"),
           call. = FALSE)
  }

  if(!is.null(k)){
    if(sum(colSums(object$X) == 0) > 0)
      warning("there is *no* information about some basis coefficients")
  }

  if(is.null(k)){

    # Generate knots if missing
    k <- seq(xl, xu,
             length.out = nk + 2)[2 : nk + 1]
  }

  # Set anchor points beyond which extrapolation will occur
  xr <- xu - xl
  boundary <- c(xl - xr * 0.01, xu + xr * 0.01)

  # Generate basis functions
  i_spline_basis <- splines2::iSpline(x,
                            knots = k,
                            degree = nk,
                            Boundary.knots = boundary,
                            intercept = TRUE)

  nbasis <- dim(i_spline_basis)[2]

  # Fill in object
  object$boundary <- boundary
  object$bs.dim <- nbasis
  object$knots <- k
  class(object) <- c("moi.smooth")
  object$X <- i_spline_basis
  if(!is.null(object$xt$S))
    stop('Cannot accept supplied penalty matrices for monotonic splines',
         call. = FALSE)
  object$S <- list(diag(object$bs.dim))
  object$rank <- object$bs.dim
  object$null.space.dim <- 0
  object$C <- matrix(0, 0, ncol(object$X))
  object$random <- TRUE
  return(object)
}

#' @export
#' @author Nicholas J Clark
#' @rdname monotonic
smooth.construct.mod.smooth.spec <- function(object, data, knots){

  insight::check_if_installed("splines2")

  # Check arguments
  object$p.order <- 1
  if(object$bs.dim < 0)
    object$bs.dim <- 10
  `k(bs = 'moi')` <- object$bs.dim
  if(`k(bs = 'moi')` <= 1)
    stop("Basis dimension is too small",
         call. = FALSE)
  validate_pos_integer(`k(bs = 'moi')`)
  validate_even(`k(bs = 'moi')`)

  # Number of knots must be k / 2
  nk <- object$bs.dim / 2L

  if(!is.null(object$id))
    stop("Monotonic splines don't work with ids",
         call. = FALSE)

  # Check basis dimension
  if(length(object$term) != 1)
    stop("Monotonic basis only handles 1D smooths",
         call. = FALSE)

  # Find the data and specified knots
  x <- data[[object$term]]
  k <- knots[[object$term]]
  if(length(unique(x)) < nk)
    warning("basis dimension is larger than number of unique covariates")

  # Checks on knots
  if(is.null(k)) {
    xl <- min(x); xu <- max(x)
  } else {
    xl <- min(k); xu <- max(k);
    if(xl > min(x) || xu < max(x))
      stop("knot range does not include data",
           call. = FALSE)
    if(length(k) != nk)
      stop(paste("there should be ", nk - 1, " supplied knots"),
           call. = FALSE)
  }

  if(!is.null(k)){
    if(sum(colSums(object$X) == 0) > 0)
      warning("there is *no* information about some basis coefficients")
  }

  if(is.null(k)){

    # Generate knots if missing
    k <- seq(xl, xu,
             length.out = nk + 2)[2 : nk + 1]
  }

  # Set anchor points beyond which extrapolation will occur
  xr <- xu - xl
  boundary <- c(xl - xr * 0.01, xu + xr * 0.01)

  # Generate basis functions
  i_spline_basis <- splines2::iSpline(x,
                            knots = k,
                            degree = nk,
                            Boundary.knots = boundary,
                            intercept = TRUE)

  nbasis <- dim(i_spline_basis)[2]

  # Fill in object
  object$boundary <- boundary
  object$bs.dim <- nbasis
  object$knots <- k
  class(object) <- c("mod.smooth")
  object$X <- i_spline_basis
  if(!is.null(object$xt$S))
    stop('Cannot accept supplied penalty matrices for monotonic splines',
         call. = FALSE)
  object$S <- list(diag(object$bs.dim))
  object$rank <- object$bs.dim
  object$null.space.dim <- 0
  object$C <- matrix(0, 0, ncol(object$X))
  object$random <- TRUE
  return(object)
}

# Prediction function for the `moi' smooth class
#' @rdname monotonic
#' @importFrom mgcv Predict.matrix
#' @export
Predict.matrix.moi.smooth <- function(object, data){

  insight::check_if_installed("splines2")

  # Ensure extrapolation is flat (1st degree penalty behaviour)
  x <- data[[object$term]]
  boundary <- object$boundary
  x[x > max(boundary)] <- max(boundary)
  x[x < min(boundary)] <- min(boundary)
  Xp <- suppressWarnings(splines2::iSpline(x,
                                           knots = object$knots,
                                           degree = object$bs.dim / 2,
                                           Boundary.knots = boundary,
                                           intercept = TRUE))
  return(as.matrix(Xp))
}

# Prediction function for the `mod' smooth class
#' @rdname monotonic
#' @importFrom mgcv Predict.matrix
#' @export
Predict.matrix.mod.smooth <- function(object, data){

  insight::check_if_installed("splines2")

  # Ensure extrapolation is flat (1st degree penalty behaviour)
  x <- data[[object$term]]
  boundary <- object$boundary
  x[x > max(boundary)] <- max(boundary)
  x[x < min(boundary)] <- min(boundary)
  Xp <- suppressWarnings(splines2::iSpline(x,
                                           knots = object$knots,
                                           degree = object$bs.dim / 2,
                                           Boundary.knots = boundary,
                                           intercept = TRUE))
  return(as.matrix(Xp))
}

add_mono_model_file = function(model_file,
                               model_data,
                               mgcv_model){

  # Which smooths are monotonic?
  smooth_labs <- do.call(rbind, lapply(seq_along(mgcv_model$smooth), function(x){
    data.frame(label = mgcv_model$smooth[[x]]$label,
               class = class(mgcv_model$smooth[[x]])[1])
  }))

  # Clean labels for inclusion in Stan code
  mono_names <- smooth_labs$label[which(smooth_labs$class %in% c('moi.smooth',
                                                                 'mod.smooth'))]
  mono_names_clean <- clean_gpnames(mono_names)

  # What directions are the constraints?
  mono_directions <- smooth_labs %>%
    dplyr::filter(class %in% c('moi.smooth',
                               'mod.smooth')) %>%
    dplyr::mutate(direction = dplyr::case_when(
      class == 'moi.smooth' ~ 1,
      class == 'mod.smooth' ~ -1,
      TRUE ~ -1
    )) %>%
    dplyr::pull(direction)

  # Update model file to include constrained coefficients
  b_line <- max(grep('b[', model_file, fixed = TRUE))
  b_edits <- paste0('b[b_idx_',
                    mono_names_clean,
                    '] = abs(b_raw[b_idx_',
                    mono_names_clean,
                    ']) * ', mono_directions,
                    ';',
                    collapse = '\n')
  model_file[b_line] <- paste0(model_file[b_line],
                               '\n',
                               b_edits)
  model_file <- readLines(textConnection(model_file), n = -1)

  # Add the necessary indices to the model_data and data block
  mono_stan_lines <- ''
  for(covariate in seq_along(mono_names)){

    coef_indices <- which(grepl(mono_names[covariate],
                                names(coef(mgcv_model)), fixed = TRUE) &
                            !grepl(paste0(mono_names[covariate],':'),
                                   names(coef(mgcv_model)), fixed = TRUE) == TRUE)
    mono_stan_lines <- paste0(mono_stan_lines,
                            paste0('array[',  length(coef_indices),
                                   '] int b_idx_',
                                   mono_names_clean[covariate],
                                   '; // monotonic basis coefficient indices\n'))
    mono_idx_data <- list(coef_indices)
    names(mono_idx_data) <- paste0('b_idx_',
                                   mono_names_clean[covariate])
    model_data <- append(model_data, mono_idx_data)
  }

  model_file[grep('int<lower=0> ytimes[n, n_series];',
                  model_file, fixed = TRUE)] <-
    paste0(model_file[grep('int<lower=0> ytimes[n, n_series];',
                           model_file, fixed = TRUE)],
           '\n',
           mono_stan_lines)
  model_file <- readLines(textConnection(model_file), n = -1)

  return(list(model_file = model_file,
              model_data = model_data))
}

#' S3 methods to evaluate individual smooths
#' @param smooth currently an object that inherits from class `mgcv.smooth`
#' @param ... arguments passed to other methods
#' @export
`eval_smooth` <- function(smooth, ...) {
  UseMethod("eval_smooth")
}

#' Evaluation of a monotonically increasing function
#' These evaluation functions are needed so that gratia::draw methods work with mvgam
#' monotonic smooths
#' @rdname monotonic
#' @export
eval_smooth.moi.smooth = function(smooth,
                                  model,
                                  n = 100,
                                  n_3d = NULL,
                                  n_4d = NULL,
                                  data = NULL,
                                  unconditional = FALSE,
                                  overall_uncertainty = TRUE,
                                  dist = NULL,
                                  ...) {

  insight::check_if_installed("gratia")
  model$cmX <- model$coefficients

  ## deal with data if supplied
  data <- process_user_data_for_eval(
    data = data, model = model,
    n = n, n_3d = n_3d, n_4d = n_4d,
    id = which_smooth(
      model,
      smooth_label(smooth)
    )
  )

  by_var <- gratia::by_variable(smooth) # even if not a by as we want NA later
  if (by_var == "NA") {
    by_var <- NA_character_
  }

  ## values of spline at data
  eval_sm <- gratia::spline_values(smooth,
                                   data = data,
                                   unconditional = unconditional,
                                   model = model,
                                   overall_uncertainty = overall_uncertainty
  )

  ## add on info regarding by variable
  eval_sm <- add_by_var_column(eval_sm, by_var = by_var)
  ## add on spline type info
  eval_sm <- add_smooth_type_column(eval_sm, sm_type = "Mono inc P spline")

  # set some values to NA if too far from the data
  if (gratia::smooth_dim(smooth) == 2L && (!is.null(dist) && dist > 0)) {
    eval_sm <- too_far_to_na(smooth,
                             input = eval_sm,
                             reference = model[["model"]],
                             cols = c(".estimate", ".se"),
                             dist = dist
    )
  }
  ## return
  eval_sm
}

#' Evaluation of a monotonically decreasing function
#' @rdname monotonic
#' @param model an object of class `"gam"`
#' @param smooth a smooth object of class `"moi.smooth"` or `"mod.smooth"`
#' @param n numeric; the number of points over the range of the covariate at
#'   which to evaluate the smooth.
#' @param n_3d,n_4d numeric; the number of points over the range of last
#'   covariate in a 3D or 4D smooth. The default is `NULL` which achieves the
#'   standard behaviour of using `n` points over the range of all covariate,
#'   resulting in `n^d` evaluation points, where `d` is the dimension of the
#'   smooth. For `d > 2` this can result in very many evaluation points and slow
#'   performance. For smooths of `d > 4`, the value of `n_4d` will be used for
#'   all dimensions `> 4`, unless this is `NULL`, in which case the default
#'   behaviour (using `n` for all dimensions) will be observed.
#' @param data a data frame of covariate values at which to evaluate the
#'   smooth.
#' @param unconditional logical; should confidence intervals include the
#'   uncertainty due to smoothness selection? If `TRUE`, the corrected Bayesian
#'   covariance matrix will be used.
#' @param overall_uncertainty logical; should the uncertainty in the model
#'  constant term be included in the standard error of the evaluate values of
#'  the smooth?
#' @param dist numeric; if greater than 0, this is used to determine when
#'   a location is too far from data to be plotted when plotting 2-D smooths.
#'   The data are scaled into the unit square before deciding what to exclude,
#'   and `dist` is a distance within the unit square. See
#'   [mgcv::exclude.too.far()] for further details.
#' @param ... ignored.
#' @export
eval_smooth.mod.smooth = function(smooth,
                                  model,
                                  n = 100,
                                  n_3d = NULL,
                                  n_4d = NULL,
                                  data = NULL,
                                  unconditional = FALSE,
                                  overall_uncertainty = TRUE,
                                  dist = NULL,
                                  ...) {
  insight::check_if_installed("gratia")
  model$cmX <- model$coefficients

  ## deal with data if supplied
  data <- process_user_data_for_eval(
    data = data, model = model,
    n = n, n_3d = n_3d, n_4d = n_4d,
    id = which_smooth(
      model,
      smooth_label(smooth)
    )
  )

  by_var <- gratia::by_variable(smooth) # even if not a by as we want NA later
  if (by_var == "NA") {
    by_var <- NA_character_
  }

  ## values of spline at data
  eval_sm <- gratia::spline_values(smooth,
                                   data = data,
                                   unconditional = unconditional,
                                   model = model,
                                   overall_uncertainty = overall_uncertainty
  )

  ## add on info regarding by variable
  eval_sm <- add_by_var_column(eval_sm, by_var = by_var)
  ## add on spline type info
  eval_sm <- add_smooth_type_column(eval_sm, sm_type = "Mono dec P spline")

  # set some values to NA if too far from the data
  if (gratia::smooth_dim(smooth) == 2L && (!is.null(dist) && dist > 0)) {
    eval_sm <- too_far_to_na(smooth,
                             input = eval_sm,
                             reference = model[["model"]],
                             cols = c(".estimate", ".se"),
                             dist = dist
    )
  }
  ## return
  eval_sm
}

#' Utility functions; full credit goes to Gavin Simpson, the developer and
#' maintainer of the gratia package
#' @noRd
`is.gamm` <- function(object) {
  inherits(object, "gamm")
}

#' @noRd
`is.gamm4` <- function(object) {
  is.list(object) & (!is.null(object[["gam"]]))
}

#' @noRd
`is.gam` <- function(object) {
  inherits(object, "gam")
}

#' @noRd
`is.bam` <- function(object) {
  inherits(object, "bam")
}

#' @noRd
`which_smooth` <- function(object, term) {
  if (is.gamm(object) || is.gamm4(object)) {
    object <- object[["gam"]]
  }
  smooths <- smooths(object)
  which(term == smooths)
}

#' @noRd
`process_user_data_for_eval` <- function(
    data, model, n, n_3d, n_4d, id,
    var_order = NULL) {
  if (is.null(data)) {
    data <- smooth_data(
      model = model,
      n = n,
      n_3d = n_3d,
      n_4d = n_4d,
      id = id,
      var_order = var_order
    )
  } else {
    smooth <- get_smooths_by_id(model, id)[[1L]]
    vars <- smooth_variable(smooth)
    by_var <- by_variable(smooth)
    if (!identical(by_var, "NA")) {
      vars <- append(vars, by_var)
    }
    ## if this is a by variable, filter the by variable for the required
    ## level now
    if (gratia::is_factor_by_smooth(smooth)) {
      data <- data %>% filter(.data[[by_var]] == gratia::by_level(smooth))
    }
  }
  data
}

#' @noRd
`add_by_var_column` <- function(object, by_var, n = NULL) {
  if (is.null(n)) {
    n <- NROW(object)
  }
  insight::check_if_installed("tibble")
  tibble::add_column(object, .by = rep(by_var, times = n), .after = 1L)
}

#' @noRd
`add_smooth_type_column` <- function(object, sm_type, n = NULL) {
  if (is.null(n)) {
    n <- NROW(object)
  }
  insight::check_if_installed("tibble")
  tibble::add_column(object, .type = rep(sm_type, times = n), .after = 1L)
}
