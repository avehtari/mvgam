---
title: 'mvgam case study 1: model comparison and data assimilation'
author: "Nicholas Clark (n.clark@uq.edu.au)"
output:
  html_document:
    df_print: paged
  pdf_document:
    highlight: zenburn
  word_document: default
urlcolor: blue
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
opts_chunk$set(tidy.opts=list(width.cutoff=40),tidy=TRUE)
```

Generalised Additive Models (GAMs) are incredibly flexible tools that have found particular application in the analysis of time series. In ecology, a host of recent papers and workshops (i.e. the [2018 Ecological Society of America workshop on GAMs](https://noamross.github.io/mgcv-esa-2018/) that was hosted by Eric Pedersen, David L. Miller, Gavin Simpson, and Noam Ross) have drawn special attention to the wide range of applications that GAMs have for addressing complex ecological problems. Given the many ways that GAMs can model temporal data, it is tempting to use the smooth functions estimated by a GAM to produce out of sample forecasts. Here we will inspect the behaviours of smoothing splines when extrapolating to data outside the range of the training data to examine whether this can be useful in practice. 

We will work in the `mvgam` package, which fits dynamic GAMs (DGAMs) using MCMC sampling via the `JAGS` software (Note that `JAGS` is required; installation links are found [here](https://sourceforge.net/projects/mcmc-jags/files/)). Briefly, assume $\tilde{\boldsymbol{y}}_{t}$ is the conditional expectation of a discrete response variable $\boldsymbol{y}$ at time $\boldsymbol{t}$. Asssuming $\boldsymbol{y}$ is drawn from an exponential distribution (such as Poisson or Negative Binomial) with a log link function, the linear predictor for a dynamic GAM is written as:

$$log(\tilde{\boldsymbol{y}}_{t})={\boldsymbol{B}}_0+\sum\limits_{i=1}^I\boldsymbol{s}_{i,t}\boldsymbol{x}_{i,t}+\boldsymbol{z}_{t}\,,$$
Here $\boldsymbol{B}_{0}$ is the unknown intercept, the $\boldsymbol{s}$'s are unknown smooth functions of the covariates ($\boldsymbol{x}$'s) and $\boldsymbol{z}$ is a dynamic latent trend component. Each smooth function $\boldsymbol{s}_{i}$ is composed of spline like basis expansions whose coefficients, which must be estimated, control the shape of the functional relationship between $\boldsymbol{x}_{i}$ and $log(\tilde{\boldsymbol{y}})$. The size of the basis expansion limits the smooth’s potential complexity, with a larger set of basis functions allowing greater flexibility. Several advantages of GAMs are that they can model a diversity of response families, including discrete distributions (i.e. Poisson or Negative Binomial) that accommodate ecological features such as zero-inflation, and that they can be formulated to include hierarchical smoothing for multivariate responses. For the dynamic component, in its most basic form we assume a random walk with drift:

$$\boldsymbol{z}_{t}=\phi+\boldsymbol{z}_{t-1}+\boldsymbol{e}_{t}\,,$$
where $\phi$ is an optional drift parameter (if the latent trend is assumed to not be stationary) and $\boldsymbol{e}$ is drawn from a zero-centred Gaussian distribution. This model is easily modified to include autoregressive terms, which `mvgam` accomodates up to `order = 3`.

#Why DGAMs?
Dynamic GAMs are useful when we wish to predict future values from time series that show temporal dependence and we want to avoid extrapolating from a smooth (which, as you’ll see below, can sometimes lead to unpredictable and unrealistic behaviours). In addition, smooths can often try to wiggle excessively to capture any autocorrelation that is present in a time series, which exacerbates the problem of forecasting ahead. Here we use an exaggerated example to show how a smooth tries to wiggle excessively, leading to overfitting by lessening the smoothing penalty $\lambda$. Notice how wiggly the function becomes in the last plot when $\lambda$ is very small, which is what `mgcv`’s `gam.check` function will often tell you to do if you are trying to model an autocorrelated time series with a smooth function
```{r, fig.width = 6, fig.height = 5.5, fig.align='center'}
# Fit a model to the mcycle dataset in the MASS package, fixing the smoothing parameter at an abnormally large value
par(mfrow = c(2, 2),
    mgp = c(2.5, 1, 0),
    mai = c(0.6, 0.6, 0.2, 0.2))
library(mgcv)
data(mcycle, package = 'MASS')

m1 <- gam(accel ~ s(times, k = 50), data = mcycle, method = 'REML', sp = 5)

plot(m1, scheme = 1, residuals = TRUE, pch= 16,
     ylab = expression(lambda == 5), xlab = '',
     shade.col = scales::alpha("#B97C7C", 0.6))

# Fit models with increasingly relaxed smooths (lambdas approaching zero)
m2 <- gam(accel ~ s(times, k = 50), data = mcycle, method = 'REML', sp = 1)
plot(m2, scheme = 1, residuals = TRUE, pch= 16,
     ylab = expression(lambda == 1), xlab = '',
     shade.col = scales::alpha("#B97C7C", 0.6))

m3 <- gam(accel ~ s(times, k = 50), data = mcycle, method = 'REML', sp = 0.01)
plot(m3, scheme = 1, residuals = TRUE, pch= 16,
     ylab = expression(lambda == 0.01), xlab = '',
     shade.col = scales::alpha("#B97C7C", 0.6))

m4 <- gam(accel ~ s(times, k = 50), data = mcycle, method = 'REML', sp = 0.0000001)
plot(m4, scheme = 1, residuals = TRUE, pch= 16,
     ylab = expression(lambda == 0.0000001), xlab = '',
     shade.col = scales::alpha("#B97C7C", 0.6))
```

#AirPassengers example
Now onto an empirical example. First we load the `AirPassengers` data from the `forecast` package and convert to an `xts` object. This series is a good starting point as it should be highly forecastable given its stable seasonal pattern and nearly linear trend
```{r message=FALSE, warning = FALSE}
#devtools::install_github("nicholasjclark/mvgam")
library(mvgam)
library(dplyr)
library(xts)
library(forecast)
data("AirPassengers")
series <- xts::as.xts(floor(AirPassengers))
colnames(series) <- c('Air')
```

View the raw series, its STL decomposition and the distribution of observations. There is a clear seasonal pattern as well as an increasing trend over time for this series, and the distribution shows evidence of a skew suggestive of overdispersion
```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot(series)
plot(stl(series, s.window = 'periodic'))
hist(series)
```

Next use the `series_to_mvgam` function, which converts `ts` or `xts` objects into the correct format for `mvgam`. Here we set `train_prop = 0.75`, meaning we will include ~ 75% of the observations in the training set and use the remaining ~25% for forecast validation. We also randomly set ~10% of observations to `NA` so that we can evaluate models based on their predictive abilities
```{r}
series[sample(1:length(series), floor(length(series)/10), F)] <- NA
fake_data <- series_to_mvgam(series, freq = 12, train_prop = 0.75)
```

Examine the returned object
```{r}
head(fake_data$data_train)
head(fake_data$data_test)
```

As a first pass at modelling this series, we will fit a GAM that includes a seasonal smooth and a yearly smooth, as well as their tensor product interaction. As the seasonality is cyclic, we will use a cyclic cubic regression spline for `season`. The knots are set so that the boundaries of the cyclic smooth match up between December 31 and January 1. We will stick with the default thin plate regression spline for `year`. This is similar to what we might do when fitting a model in `mgcv` to try and forecast ahead, except here we also have an explicit model for the residual component. `mvgam` uses the `jagam` function from the `mgcv` package to generate a skeleton `JAGS` file and updates that file to incorporate any dynamic trend components (so far limited to no trend, random walks or AR models up to order 3). This is advantageous as any GAM that is allowed in `mgcv` can in principle be used in `mvgam` to fit dynamic linear models with smooth functions for nonlinear covariate effects. For multivariate series, `mvgam` also includes an option for dimension reduction by inducing trend correlations via a dynamic factor process. Here we use the Negative Binomial family and a burnin length of `10000` iterations (in practice we would probably run these models for a bit longer, but they tend to converge rather quickly for univariate series thanks to the useful starting values supplied by `jagam`). Note that feeding the `data_test` object does not mean that these values are used in training of the model. Rather, they are included as `NA` so that we can automatically create a forecast from the posterior predictions for these observations. This is useful for plotting forecasts without needing to run new data through the model's equations later on
```{r, message=FALSE, warning=FALSE}
mod1 <- mvjagam(data_train = fake_data$data_train,
               data_test = fake_data$data_test,
               formula = y ~ s(season, bs = c('cc'), k = 12) +
                 s(year, k = 5) +
                  ti(season, year, bs = c('cc', 'tp'), k = c(12, 3)),
               knots = list(season = c(0.5, 12.5)),
               family = 'nb',
               trend_model = 'None',
               burnin = 1000,
               chains = 4)
```

We can view the `JAGS` model file that has been generated to see the additions that have been made to the base `gam` model. If the user selects `return_jags_data = TRUE` when calling `mvjagam`, this file can be modified and the resulting `jags_data` object can also be modified to fit more complex Bayesian models. Note that here the AR and phi terms have been set to zero as this model does not include a dynamic trend component
```{r}
mod1$model_file
```

Inspect the summary from the model, which is somewhat similar to an `mgcv` model summary with extra information about convergences for unobserved parameters. The estimated degrees of freedom, smooth coefficients and smooth penalties are all extracted from the `mvgam` model using `sim2jam` so that approximate p-values can be calculated using Nychka's method (following Wood (2013) Biometrika 100(1), 221-228). Note however that this function is still in development and approximate p-values may not be entirely accurate
```{r}
summary_mvgam(mod1)
```

`mvgam` takes a fitted `gam` model and adapts the model file to fit in `JAGS`, with possible extensions to deal with stochastic trend components and other features. But as this model has not been modified much from the original `gam` model with the same formula (i.e. we have not added any stochastic trend components to the linear predictor yet, which is the main feature of `mvgam`), the summary of the unmodified `gam` model is also useful and fairly accurate 
```{r}
summary(mod1$mgcv_model)
```

Ordinarily we would be quite pleased with this result, as we have explained most of the variation in the series with a fairly simple model. We can plot the estimated smooth functions and their associated credible intervals, which are interpreted similarly to `mgcv` plots with the exception of the partial residuals. `mvgam` uses Dunn-Smyth residuals that are drawn from a standard normal distribution rather than working or pearson residuals as in `mgcv`
```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_smooth(mod1, series = 1, smooth = 'season')
```

Overlay the partial residuals on the same smooth plot
```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_smooth(mod1, series = 1, smooth = 'season', residuals = TRUE)
```


And here is the plot of the smooth function for `year`, which has essentially estimated a straight line
```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_smooth(mod1, series = 1, smooth = 'year')
```

Perform a series of posterior predictive checks to see if the model is able to simulate data for the training period that looks realistic and unbiased. First, examine simulated kernel densities for posterior predictions (`yhat`) and compare to the density of the observations (`y`)
```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_ppc(mod1, series = 1, type = 'density', legend_position = 'bottomright')
```

Now plot the distribution of predicted means compared to the observed mean
```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_ppc(mod1, series = 1, type = 'mean')
```

Next examine simulated empirical Cumulative Distribution Functions (CDF) for posterior predictions (`yhat`) and compare to the CDF of the observations (`y`)
```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_ppc(mod1, series = 1, type = 'cdf')
```

Finally look for any biases in predictions by examining a Probability Integral Transform (PIT) histogram. If our predictions are not biased one way or another (i.e. not consistently under- or over-predicting), this histogram should look roughly uniform
```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_ppc(mod1, series = 1, type = 'pit')
```

All of these plots indicate the model is well calibrated against the training data, with no apparent pathological behaviors exhibited. Now for some investigation of the estimated relationships and forecasts. We can also perform residual diagnostics using randomised quantile (Dunn-Smyth) residuals. These look reasonable overall, though there is some autocorrelation at lag 1 left in the residuals for this series
```{r, fig.width = 7, fig.height = 7, fig.align='center'}
plot_mvgam_resids(mod1, series = 1)
```

Ok so the model is doing well when fitting against the training data, but how are its forecasts? The yearly trend is being extrapolated into the future, which controls most of the shape and uncertainty in the forecast. We see there is a reasonable estimate of uncertainty and the out of sample observations (to the right of the dashed line) are all within the model's 95% HPD intervals
```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_fc(mod1, series = 1, data_test = fake_data$data_test)
```

The extrapolation of the smooth for `year` can be better viewed by feeding new data to the `plot_mvgam_smooth` function. Here we feed values of `year` to cover the training and testing set to see how the extrapolation would continue into the future. The dashed line marks the end of the training period
```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_smooth(mod1,
                  series = 1,
                  'year',
                  newdata = expand.grid(year = seq(min(fake_data$data_train$year),
                       max(fake_data$data_test$year),
                       length.out = 500),
                       season = mean(fake_data$data_train$season),
                       series = unique(fake_data$data_train$series)))
abline(v = max(fake_data$data_train$year), lty = 'dashed')
```

We can also re-do the posterior predictive checks, but this time focusing only on the out of sample period. This will give us better insight into how the model is performing and whether it is able to simulate realistic and unbiased future values
```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_ppc(mod1, series = 1, type = 'density', data_test = fake_data$data_test,
               legend_position = 'topright')
```

```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_ppc(mod1, series = 1, type = 'mean', data_test = fake_data$data_test)
```

```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_ppc(mod1, series = 1, type = 'cdf', data_test = fake_data$data_test)
```

```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_ppc(mod1, series = 1, type = 'pit', data_test = fake_data$data_test)
```

There are some problems with the way this model is generating future predictions. Perhaps a different smooth function for `year` can help? Here we fit our original model again but use a different smooth term for `year` to try and capture the long-term trend (using `B` splines with multiple penalties, following the excellent example by Gavin Simpson about [extrapolating with smooth terms](https://fromthebottomoftheheap.net/2020/06/03/extrapolating-with-gams/)). This is similar to what we might do when trying to forecast ahead from a more wiggly function, as `B` splines have useful properties by allowing the penalty to be extended into the range of values we wish to predict (in this case, the years in `data_test`). Note that we drop the `year*season` tensor product interaction to help emphasize the extrapolation behaviour of the `B` spline
```{r, message=FALSE, warning=FALSE}
mod2 <- mvjagam(data_train = fake_data$data_train,
               data_test = fake_data$data_test,
               formula = y ~ s(season, bs = c('cc'), k = 12) +
                 s(year, bs = "bs", m = c(2, 1)),
               knots = list(season = c(0.5, 12.5),
                            year = c(min(fake_data$data_train$year) - 1,
                                     min(fake_data$data_train$year),
                                     max(fake_data$data_train$year),
                                     max(fake_data$data_test$year))),
               family = 'nb',
               trend_model = 'None',
               burnin = 10000,
               chains = 4)
```

Again as we haven't modified the base `gam` much, the summary from the `mgcv` model is fairly accurate
```{r}
summary_mvgam(mod2)
summary(mod2$mgcv_model)
```

This model explains even more of the variation than the thin plate yearly model above, so we'd be tempted to use it for prediction (though of course we'd want to perform a series of checks following advice from Simon Wood; see [lectures by Gavin Simpson for more information on how to perform these checks](https://www.youtube.com/user/ucfagls)). So how do the forecasts look?
```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_fc(mod2, series = 1, data_test = fake_data$data_test)
```

Again the forecast is being driven primarily by the extrapolation behaviour of the `B` spline. Look at this behaviour for the `year` smooth as we did above by feeding new data for prediction
```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_smooth(mod2,
                  series = 1,
                  'year',
                  newdata = expand.grid(year = seq(min(fake_data$data_train$year),
                       max(fake_data$data_test$year),
                       length.out = 500),
                       season = mean(fake_data$data_train$season),
                       series = unique(fake_data$data_train$series)))
abline(v = max(fake_data$data_train$year), lty = 'dashed')
```

Residual and posterior in-training predictive checks for this model will look similar to the above, with some autocorrelation left in residuals but nothing terribly alarming. But the forecast checks again show some problems:
```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_ppc(mod2, series = 1, type = 'density', data_test = fake_data$data_test)
```

```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_ppc(mod2, series = 1, type = 'mean', data_test = fake_data$data_test)
```

```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_ppc(mod2, series = 1, type = 'cdf', data_test = fake_data$data_test)
```

```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_ppc(mod2, series = 1, type = 'pit', data_test = fake_data$data_test)
```

Can we improve the forecasts by removing our reliance on extrapolation? Now we will fit a model in which the GAM component of the linear predictor captures the repeated seasonality (again with a cyclic smooth) and a dynamic latent trend captures the temporal residual process using AR parameters (up to order 3). This model is a mildly modified version of the base `mgcv` model where the linear predictor is augmented with the latent trend component. Slightly longer burnin is used here due to the added complexity of the time series component, but the model still fits in ~ 30 seconds on most machines
```{r, message=FALSE, warning=FALSE}
mod3 <- mvjagam(data_train = fake_data$data_train,
                data_test = fake_data$data_test,
                formula = y ~ s(season, bs = c('cc'), k = 12),
                knots = list(season = c(0.5, 12.5)),
                family = 'nb',
                trend_model = 'AR3',
                drift = TRUE,
                burnin = 12000,
               chains = 4)
```
               
In this case the fitted model is more different to the base `mgcv` model that was used in `jagam` to produce the skeleton `JAGS` file, so the summary of that base model is less accurate. But we can still check the model summary for the `mvjagam` mdoel to examine convergence for key parameters
```{r}
summary_mvgam(mod3)
```

The seasonal term is obviously still very important. Plot it here
```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_smooth(mod3, series = 1, 'season')
```

Plot diagnostics of posterior Dunn-Smyth residuals, where the autocorrelation is now captured by the latent trend process
```{r, fig.width = 7, fig.height = 7, fig.align='center'}
plot_mvgam_resids(mod3, series = 1)
```

How does the model's posterior forecast distribution compare to the previous models?
```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_fc(mod3, series = 1, data_test = fake_data$data_test)
```

```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_ppc(mod3, series = 1, type = 'density', data_test = fake_data$data_test)
```

```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_ppc(mod3, series = 1, type = 'mean', data_test = fake_data$data_test)
```

```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_ppc(mod3, series = 1, type = 'cdf', data_test = fake_data$data_test)
```

```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_ppc(mod3, series = 1, type = 'pit', data_test = fake_data$data_test)
```

None of the model's is a perfect representation of the data generating process, but the forecast for our dynamic GAM is more stable and more accurate than the previous models, with the added advantage that we can place more trust our estimated smooth for `season` because we have captured the residual autocorrelation. The posterior checks for our dynamic GAM also look much better than the two previous models. Plot the estimated latent dynamic trend (which is on the log scale)
```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_trend(mod3, series = 1, data_test = fake_data$data_test)
```

Benchmarking against "null" models is a very important part of evaluating a proposed forecast model. After all, if our complex dynamic model can't generate better predictions then a random walk or mean forecast, is it really telling us anything new about the data-generating process? Here we examine the model comparison utilities in `mvgam`. Here we illustrate how this can be done in `mvgam` by fitting a simpler model by smoothing on a white noise covariate rather than on the seasonal variable. Because the white noise covariate is not informative and we are using a random walk for the trend process, this model essentially becomes a Poisson observation model over a dynamic random walk process.
```{r, message=FALSE, warning=FALSE}
fake_data$data_train$fake_cov <- rnorm(NROW(fake_data$data_train))
fake_data$data_test$fake_cov <- rnorm(NROW(fake_data$data_test))
mod4 <- mvjagam(data_train = fake_data$data_train,
               data_test = fake_data$data_test,
               formula = y ~ s(fake_cov, k = 3),
               family = 'poisson',
               trend_model = 'RW',
               drift = TRUE,
               burnin = 10000,
               chains = 4)
```

Look at this model's proposed forecast
```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_fc(mod4, series = 1, data_test = fake_data$data_test)
```

Inspecting the model's smooth function for the fake covariate `fake_cov` shows that the function is essentially flat and there is no structure in the expected partial residuals, suggesting there would be no stucture remaining if we were to drop this term from the model. Together this evidence indicates that the function is unimportant
```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot_mvgam_smooth(mod4, series = 1, smooth = 'fake_cov', residuals = T)
```

Now we will showcase how different dynamic models can be compared using rolling probabilistic forecast evaluation, which is especially useful if we don't already have out of sample observations for comparing forecasts. This function sets up a sequence of evaluation timepoints along a rolling window within the training data to evaluate 'out-of-sample' forecasts. The trends are rolled forward a total of `fc_horizon` timesteps according to their estimated state space dynamics to generate an 'out-of-sample' forecast that is evaluated against the true observations in the `horizon` window. We are therefore simulating a situation where the model's parameters had already been estimated but we have only observed data up to the evaluation timepoint and would like to generate forecasts that consider the possible future paths for the latent trends and the true observed values for any other covariates in the `horizon` window. Evaluation involves calculating the Discrete Rank Probability Score and a binary indicator for whether or not the true value lies within the forecast's 90% prediction interval. For this test we compare the two models on the exact same sequence of `30` evaluation points using `horizon = 6`
```{r, fig.width = 6, fig.height = 5, fig.align='center'}
compare_mvgams(model1 = mod3, model2 = mod4, fc_horizon = 6,
               n_evaluations = 30, n_cores = 3)
```

The series of plots generated by `compare_mvgams` clearly show that the first dynamic model generates better predictions. In each plot, DRPS for the forecast `horizon` is lower for the first model than for the second model. This kind of evaluation is often more appropriate for forecast models than complexity-penalising fit metrics such as [`AIC` or `BIC`](https://www.sciencedirect.com/science/article/pii/S0169207020301096) However, comparing forecasts of the dynamic models against the two models with yearly smooth terms (`mod1` and `mod2`) using the rolling window approach is actually not recommended, as the yearly smooth models have already seen all the possible in-sample values of `year` and so should be able to predict incredibly well by interpolating through the range of the fitted smooth. By contrast, the dynamic component in our dynamic GAMs (models 3 and 4) produce true forecasts when running the rolling window approach. Nevertheless, when we compare some of these models (here `mod1` with the thin plate yearly smooth vs `mod3` with the AR3 trend process) as we did above for the random walk model, we still find that our dynamic GAM produces superior probabilistic forecasts
```{r,  fig.width = 6, fig.height = 5, fig.align='center'}
compare_mvgams(model1 = mod1, model2 = mod3, fc_horizon = 6,
               n_evaluations = 30, n_cores = 3)
```

The same holds true when comparing against the `B` spline model (`mod2`)
```{r,  fig.width = 6, fig.height = 5, fig.align='center'}
compare_mvgams(model1 = mod2, model2 = mod3, fc_horizon = 6,
               n_evaluations = 30, n_cores = 3)
```

Now we proceed by exploring how forecast distributions from an `mvgam` object can be automatically updated in light of new incoming observations. This works by generating a set of "particles" that each captures a unique proposal about the current state of the system (in this case, the current estimate of the latent trend component). The next observation in `data_assim` is assimilated and particles are weighted by how well their proposal (i.e. their proposed forecast, prior to seeing the new data) matched the new observations. For univariate models such as the ones we've fitted so far, this weight is represented by the proposal's Negative Binomial log-likelihood. For multivariate models, a multivariate composite likelihood is used for weights. Once weights are calculated, we use importance sampling to update the model's forecast distribution for the remaining forecast horizon. Begin by initiating a set of `15000` particles by assimilating the next observation in `data_test` and storing the particles in the default location (in a directory called `particles` within the working directory)
```{r}
pfilter_mvgam_init(object = mod3, n_particles = 15000, n_cores = 3,
                   data_assim = fake_data$data_test)
```

Now we are ready to run the particle filter. This function will assimilate the next six out of sample observations in `data_test` and update the forecast after each assimilation step. This works in an iterative fashion by calculating each particle's weight, then using a kernel smoothing algorithm to "pull" low weight particles toward the high-likelihood space before assimilating the next observation. The strength of the kernel smoother is controlled by `kernel_lambda`, which in our experience works well when left to the default of `1`. If the Effective Sample Size of particles drops too low, suggesting we are putting most of our belief in a very small set of particles, an automatic resampling step is triggered to increase particle diversity and reduce the chance that our forecast intervals become too narrow and incapable of adapting to changing conditions
```{r}
pfilter_mvgam_online(data_assim = fake_data$data_test[1:7,], 
                     n_cores = 3,
                     kernel_lambda = 1)
```

Once assimilation is complete, generate the updated forecast from the particles using the covariate information in remaining `data_test` observations. This function is designed to hopefully make it simpler to assimilate observations, as all that needs to be provided once the particles are initiated as a dataframe of test data in exactly the same format as the data that were used to train the initial model. If no new observations are found (observations are arranged by `year` and then by `season` so the consistent indexing of these two variables is very important!) then the function returns a `NULL` and the particles remain where they are in state space.
```{r}
fc <- pfilter_mvgam_fc(file_path = 'pfilter', n_cores = 3,
                       data_test = fake_data$data_test,
                       ylim = c(min(fake_data$data_train$y, na.rm = T),
                                max(fake_data$data_test$y, na.rm = T)*1.25))
```

Compare the updated forecast to the original forecast to see how it has changed in light of the most recent observations
```{r, fig.width = 7.5, fig.height = 4.5, fig.align='center'}
par(mfrow=c(1,2))
plot_mvgam_fc(mod3, series = 1, data_test = fake_data$data_test,
              ylim = c(min(fake_data$data_train$y, na.rm = T), 
                       max(fake_data$data_test$y, na.rm = T)*1.25))
fc$Air()
```

Here it is apparent that the distribution has shifted slightly in light of the `6` observations that have been assimilated, and that our confidence in the remaining forecast horizon has improved (tighter uncertainty intervals). This is an advantageous way of allowing a model to slowly adapt to new conditions while breaking free of restrictive assumptions about residual distributions. [See some of the many particle filtering lectures by Nathaniel Osgood for more details](https://www.youtube.com/user/NathanielOsgood). Remove the particles from their stored directory when finished
```{r}
unlink('pfilter', recursive = T)
```

#Lynx example
For our next univariate example, we will again pursue how challenging it can be to forecast ahead with conventional GAMs and how `mvgam` overcomes these challenges. We begin by replicating the lynx analysis from [2018 Ecological Society of America workshop on GAMs](https://noamross.github.io/mgcv-esa-2018/) that was hosted by Eric Pedersen, David L. Miller, Gavin Simpson, and Noam Ross, with some minor adjustments. First, load the data and plot the series as well as its estimated autocorrelation function
```{r, fig.show='hold', fig.align='center'}
data(lynx)
lynx_full = data.frame(year = 1821:1934, 
                       population = as.numeric(lynx),
                       time = 1:NROW(lynx))
plot(lynx_full$population, type = 'l', ylab = 'Lynx trappings',
     xlab = 'Time')
acf(lynx_full$population, main = '')
```


There is a clear ~19-year cyclic pattern to the data, so I create a `season` term that can be used to model this effect and give a better representation of the data generating process. I also create a new `year` term that represents which long-term cycle each observation is in
```{r, fig.width = 5, fig.height = 4, fig.align='center'}
plot(stl(ts(lynx_full$population, frequency = 19), s.window = 'periodic'))
lynx_full$season <- (lynx_full$year %%19) + 1
cycle_ends <- c(which(lynx_full$season == 19), NROW(lynx_full))
cycle_starts <- c(1, cycle_ends[1:length(which(lynx_full$season == 19))] + 1)
cycle <- vector(length = NROW(lynx_full))
for(i in 1:length(cycle_starts)){
  cycle[cycle_starts[i]:cycle_ends[i]] <- i
}
lynx_full$year <- cycle
```


Add lag indicators needed to fit the nonlinear lag models that gave the best one step ahead point forecasts in the ESA workshop example. As in the example, we specify the `default` argument in the `lag` function as the mean log population.
```{r}
mean_pop_l = mean(log(lynx_full$population))
lynx_full = dplyr::mutate(lynx_full,
                   popl = log(population),
                   lag1 = dplyr::lag(popl,1, default = mean_pop_l),
                   lag2 = dplyr::lag(popl,2, default = mean_pop_l),
                   lag3 = dplyr::lag(popl,3, default = mean_pop_l),
                   lag4 = dplyr::lag(popl,4, default = mean_pop_l),
                   lag5 = dplyr::lag(popl,5, default = mean_pop_l),
                   lag6 = dplyr::lag(popl,6, default = mean_pop_l))
```

For `mvgam` models, the response needs to be labelled `y` and we also need an indicator of the series name as a `factor` variable
```{r}
lynx_full$y <- lynx_full$population
lynx_full$series <- factor('series1')
```

Split the data into training (first 40 years) and testing (next 10 years of data) to evaluate multi-step ahead forecasts
```{r}
lynx_train = lynx_full[1:40, ]
lynx_test = lynx_full[41:50, ]
```

The best-forecasting model in the course was with nonlinear smooths of lags 1 and 2; we use those here is that we also include a cyclic smooth for the 19-year cycles as this seems like an important feature, as well as a yearly smooth for the long-term trend. Following the information about spline extrapolation above, we again fit a cubic `B` spline for the trend with a mix of penalties to try and reign in wacky extrapolation behaviours, and we extend the penalty to cover the years that we wish to predict. This will hopefully give us better uncertainty estimates for the forecast. In this example we assume the observations are Poisson distributed
```{r, message=FALSE, warning=FALSE}
lynx_mgcv = gam(population ~ 
                  s(season, bs = 'cc', k = 19) +
                  s(year, bs = 'bs', m = c(3, 2, 1, 0)) + 
                  s(lag1, k = 5) +
                  s(lag2, k = 5),
               knots = list(season = c(0.5, 19.5),
                            year = c(min(lynx_train$year - 1),
                                     min(lynx_train$year),
                                     max(lynx_test$year),
                                     max(lynx_test$year) + 1)),
                data = lynx_train, family = "poisson",
                method = "REML")
```

Inspect the model's summary and estimated smooth functions for the season, year and lag terms
```{r, fig.show='hold', fig.align='center'}
summary(lynx_mgcv)
plot(lynx_mgcv, select = 1)
plot(lynx_mgcv, select = 2)
plot(lynx_mgcv, select = 3)
plot(lynx_mgcv, select = 4)
```

This model captures most of the deviance in the series and the functions are all confidently estimated to be non-zero and non-flat. So far, so good. Now for some forecasts for the out of sample period. First we must take posterior draws of smooth beta coefficients to incorporate the uncertainties around smooth functions when simulating forecast paths
```{r}
coef_sim <- gam.mh(lynx_mgcv)$bs
```


Now we define a function to perform forecast simulations from the nonlinear lag model in a recursive fashion. Using starting values for the last two lags, the function will iteratively project the path ahead with a random sample from the model's coefficient posterior
```{r}
recurse_nonlin = function(model, lagged_vals, h){
  # Initiate state vector
  states <- rep(NA, length = h + 2)
  # Last two values of the conditional expectations begin the state vector
  states[1] <- as.numeric(exp(lagged_vals[2]))
  states[2] <- as.numeric(exp(lagged_vals[1]))
  # Get a random sample of the smooth coefficient uncertainty matrix
  # to use for the entire forecast horizon of this particular path
  gam_coef_index <- sample(seq(1, NROW(coef_sim)), 1, T)
  # For each following timestep, recursively predict based on the
  # predictions at each previous lag
  for (t in 3:(h + 2)) {
    # Build the GAM linear predictor matrix using the two previous lags
    # of the (log) density
    newdata <- data.frame(lag1 = log(states[t-1] + 0.01),
                          lag2 = log(states[t-2] + 0.01),
                          season = lynx_test$season[t-2],
                          year = lynx_test$year[t-2])
    colnames(newdata) <- c('lag1', 'lag2', 'season', 'year')
    Xp <- predict(model, newdata = newdata, type = 'lpmatrix')
    # Calculate the posterior prediction for this timepoint
    mu <- rpois(1, lambda = exp(Xp %*% coef_sim[gam_coef_index,]))
    # Fill in the state vector and iterate to the next timepoint
    states[t] <- mu
  }
  # Return the forecast path
  states[-c(1:2)]
}
```

Create the GAM's forecast distribution by generating `1000` simulated forecast paths. Each path is fed the true observed values for the last two lags of the first out of sample timepoint, but they can deviate when simulating ahead depending on their particular draw of possible coefficients. Note, this is a bit slow and could easily be parallelised to speed up computations
```{r}
gam_sims <- matrix(NA, nrow = 1000, ncol = 10)
for(i in 1:1000){
  gam_sims[i,] <- recurse_nonlin(lynx_mgcv,
                                 lagged_vals = c(lynx_test$lag1[1],
                                                 lynx_test$lag2[1]),
                                 h = 10)
}
```

Plot the mgcv model's out of sample forecast for the next 10 years ahead
```{r, fig.width=5, fig.height=4, fig.align='center'}
cred_ints <- apply(gam_sims, 2, function(x) hpd(x, 0.95))
yupper <- max(cred_ints) * 1.25
plot(cred_ints[3,] ~ seq(1:NCOL(cred_ints)), type = 'l',
     col = rgb(1,0,0, alpha = 0),
     ylim = c(0, yupper),
     ylab = 'Predicted lynx trappings',
     xlab = 'Forecast horizon',
     main = 'mgcv')
polygon(c(seq(1:(NCOL(cred_ints))), rev(seq(1:NCOL(cred_ints)))),
        c(cred_ints[1,],rev(cred_ints[3,])),
        col = rgb(150, 0, 0, max = 255, alpha = 100), border = NA)
cred_ints <- apply(gam_sims, 2, function(x) hpd(x, 0.68))
polygon(c(seq(1:(NCOL(cred_ints))), rev(seq(1:NCOL(cred_ints)))),
        c(cred_ints[1,],rev(cred_ints[3,])),
        col = rgb(150, 0, 0, max = 255, alpha = 180), border = NA)
lines(cred_ints[2,], col = rgb(150, 0, 0, max = 255), lwd = 2, lty = 'dashed')
points(lynx_test$population[1:10], pch = 16)
lines(lynx_test$population[1:10])
```

A decent forecast? The shape is certainly correct, but the 95% uncertainty intervals appear to be far too wide (i.e. our upper interval extends to up to ~8 times the maximum number of trappings that have ever been recorded up to this point). This is almost entirely due to the extrapolation behaviour of the B spline, as the lag smooth functions are not encountering values very far outside the ranges they've already been trained on so they are resorting mostly to interpolation. But a better way to evaluate than simply using visuals is to calculate a probabilistic score. Here we use the Discrete Rank Probabiilty Score, which gives us an indication of how well calibrated our forecast's uncertainty intervals are by comparing the mass of the forecast density against the true observed values. Forecasts with overly wide intervals are penalised, as are forecasts with overly narrow intervals that do not contain the true observations. At the same time we calculate coverage of the forecast's 90% intervals, which is another useful way of evaluating different forecast proposals
```{r}
  # Discrete Rank Probability Score and coverage of 90% interval
  drps_score <- function(truth, fc, interval_width = 0.9){
    nsum <- 1000
    Fy = ecdf(fc)
    ysum <- 0:nsum
    indicator <- ifelse(ysum - truth >= 0, 1, 0)
    score <- sum((indicator - Fy(ysum))^2)

    # Is value within 90% HPD?
    interval <- hpd(fc, interval_width)
    in_interval <- ifelse(truth <= interval[3] & truth >= interval[1], 1, 0)
    return(c(score, in_interval))
  }

  # Wrapper to operate on all observations in fc_horizon
  drps_mcmc_object <- function(truth, fc, interval_width = 0.9){
    indices_keep <- which(!is.na(truth))
    if(length(indices_keep) == 0){
      scores = data.frame('drps' = rep(NA, length(truth)),
                          'interval' = rep(NA, length(truth)))
    } else {
      scores <- matrix(NA, nrow = length(truth), ncol = 2)
      for(i in indices_keep){
        scores[i,] <- drps_score(truth = as.vector(truth)[i],
                                 fc = fc[,i], interval_width)
      }
    }
    scores
  }

# Calculate DRPS over the 10-year horizon for the mgcv model
lynx_mgcv1_drps <- drps_mcmc_object(truth = lynx_test$population[1:10], 
                   fc = gam_sims)
```

What if we remove the yearly trend and let the lag smooths capture more of the temporal dependencies? Will that improve the forecast distribution? Run a second model and plot the forecast (note that this plot will be on quite a different y-axis scale compared to the first plot above)
```{r, fig.width=5, fig.height=4, fig.align='center'}
lynx_mgcv2 = gam(population ~ 
                  s(season, bs = 'cc', k = 19) +
                  s(lag1, k = 5) +
                  s(lag2, k = 5),
                data = lynx_train, family = "poisson",
                method = "REML")
coef_sim <- gam.mh(lynx_mgcv2)$bs
gam_sims <- matrix(NA, nrow = 1000, ncol = 10)
for(i in 1:1000){
  gam_sims[i,] <- recurse_nonlin(lynx_mgcv2,
                                 lagged_vals = c(lynx_test$lag1[1],
                                                 lynx_test$lag2[1]),
                                 h = 10)
}
cred_ints <- apply(gam_sims, 2, function(x) hpd(x, 0.95))
yupper <- max(cred_ints) * 1.25
plot(cred_ints[3,] ~ seq(1:NCOL(cred_ints)), type = 'l',
     col = rgb(1,0,0, alpha = 0),
     ylim = c(0, yupper),
     ylab = 'Predicted lynx trappings',
     xlab = 'Forecast horizon',
     main = 'mgcv')
polygon(c(seq(1:(NCOL(cred_ints))), rev(seq(1:NCOL(cred_ints)))),
        c(cred_ints[1,],rev(cred_ints[3,])),
        col = rgb(150, 0, 0, max = 255, alpha = 100), border = NA)
cred_ints <- apply(gam_sims, 2, function(x) hpd(x, 0.68))
polygon(c(seq(1:(NCOL(cred_ints))), rev(seq(1:NCOL(cred_ints)))),
        c(cred_ints[1,],rev(cred_ints[3,])),
        col = rgb(150, 0, 0, max = 255, alpha = 180), border = NA)
lines(cred_ints[2,], col = rgb(150, 0, 0, max = 255), lwd = 2, lty = 'dashed')
points(lynx_test$population[1:10], pch = 16)
lines(lynx_test$population[1:10])
```

Calculate DRPS over the 10-year horizon for the second mgcv model
```{r}
lynx_mgcv2_drps <- drps_mcmc_object(truth = lynx_test$population[1:10], 
                   fc = gam_sims)
```

                   
This forecast is highly overconfident, with very unrealistic uncertainty intervals due to the interpolation behaviours of the lag smooths. You can certainly keep trying different formulations (our experience is that the B spline variant above produces the best forecasts from any tested `mgcv` model, but we did not test an exhaustive set), but hopefully it is clear that forecasting using splines is tricky business and it is likely that each time you do it you'll end up honing in on different combinations of penalties, knot selections etc.... Now we will fit an `mvgam` model for comparison. This model fits a similar model to the `mgcv` model directly above but with a full time series model for the errors (in this case an `AR1` process), rather than smoothing splines that do not incorporate a concept of the future. We do not use a `year` term to reduce any possible extrapolation and because the latent dynamic component should capture this temporal variation.
```{r, message=FALSE, warning=FALSE}
lynx_mvgam <- mvjagam(data_train = lynx_train,
               data_test = lynx_test,
               formula = y ~ s(season, bs = 'cc', k = 19),
               knots = list(season = c(0.5, 19.5)),
               family = 'poisson',
               trend_model = 'AR1',
               burnin = 5000,
               chains = 4)
```

Calculate the out of sample forecast from the fitted `mvgam` model and plot
```{r, fig.width=5, fig.height=4, fig.align='center'}
fits <- MCMCvis::MCMCchains(lynx_mvgam$jags_output, 'ypred')
fits <- fits[,(NROW(lynx_mvgam$obs_data)+1):(NROW(lynx_mvgam$obs_data)+10)]
cred_ints <- apply(fits, 2, function(x) hpd(x, 0.95))
yupper <- max(cred_ints) * 1.25
plot(cred_ints[3,] ~ seq(1:NCOL(cred_ints)), type = 'l',
     col = rgb(1,0,0, alpha = 0),
     ylim = c(0, yupper),
     ylab = '',
     xlab = 'Forecast horizon',
     main = 'mvgam')
polygon(c(seq(1:(NCOL(cred_ints))), rev(seq(1:NCOL(cred_ints)))),
        c(cred_ints[1,],rev(cred_ints[3,])),
        col = rgb(150, 0, 0, max = 255, alpha = 100), border = NA)
cred_ints <- apply(fits, 2, function(x) hpd(x, 0.68))
polygon(c(seq(1:(NCOL(cred_ints))), rev(seq(1:NCOL(cred_ints)))),
        c(cred_ints[1,],rev(cred_ints[3,])),
        col = rgb(150, 0, 0, max = 255, alpha = 180), border = NA)
lines(cred_ints[2,], col = rgb(150, 0, 0, max = 255), lwd = 2, lty = 'dashed')
points(lynx_test$population[1:10], pch = 16)
lines(lynx_test$population[1:10])
```

Calculate DRPS over the 10-year horizon for the mvgam model
```{r}
lynx_mvgam_drps <- drps_mcmc_object(truth = lynx_test$population[1:10], 
                   fc = fits)
```

How do the out of sample DRPS scores stack up for these three models? Remember, our goal is to minimise DRPS while providing 90% intervals that are near, but not less than, `0.9`. The DRPS and 90% interval coverage for the first `mgcv` model (with the `B` spline year term)
```{r}
sum(lynx_mgcv1_drps[,1])
mean(lynx_mgcv1_drps[,2])
```

For the second `mgcv` model
```{r}
sum(lynx_mgcv2_drps[,1])
mean(lynx_mgcv2_drps[,2])
```

And for the `mvgam` model
```{r}
sum(lynx_mvgam_drps[,1])
mean(lynx_mvgam_drps[,2])
```

The `mvgam` has much more realistic uncertainty than the `mgcv` versions above. Of course this is just one out of sample comparison, and to really determine which model is most appropriate for forecasting we would want to run many of these tests using a [rolling window approach](https://robjhyndman.com/hyndsight/tscv/). Have a look at this model's summary to see what is being estimated (note that longer MCMC runs would probably be needed to increase effective sample sizes)
```{r}
summary_mvgam(lynx_mvgam)
```

Now inspect each model's estimated smooth for the 19-year cyclic pattern. Note that the `mvgam` smooth plot is on a different scale compared to the `mgcv` plot, but interpretation is similar. The `mgcv` smooth is much wigglier, likely because it is compensating for any remaining autocorrelation not captured by the lag smooths. We could probably remedy this by reducing `k` in the seasonal smooth for the `mgcv` model (in practice this works well, but leaving `k` larger for the `mvgam`'s seasonal smooth is recommended as our experience is that this tends to lead to better performance and convergence)
```{r, fig.show='hold', fig.align='center'}
plot(lynx_mgcv, select=1, shade=T)
plot_mvgam_smooth(lynx_mvgam, 1, 'season')
```

We can also view the mvgam's posterior predictions for the entire series (testing and training)
```{r, fig.width=5, fig.height=4, fig.align='center'}
plot_mvgam_fc(lynx_mvgam, data_test = lynx_test)
```

And the estimated trend
```{r, fig.width=5, fig.height=4, fig.align='center'}
plot_mvgam_trend(lynx_mvgam, data_test = lynx_test)
```

A key aspect of ecological forecasting is to understand [how different components of a model contribute to forecast uncertainty](https://esajournals.onlinelibrary.wiley.com/doi/full/10.1002/eap.1589). We can estimate contributions to forecast uncertainty for the GAM smooth functions and the latent trend using `mvgam`
```{r, fig.width=5, fig.height=4, fig.align='center'}
plot_mvgam_uncertainty(lynx_mvgam, data_test = lynx_test)
```

Both components contribute to forecast uncertainty, with the trend component contributing more over time (as it should since this is the stochastic forecast component). This suggests we would still need some more work to learn about factors driving the dynamics of the system. But we will leave the model as-is for this example. Diagnostics of the model can also be performed using `mvgam`. Have a look at the model's residuals, which are posterior medians of Dunn-Smyth randomised quantile residuals so should follow approximate normality. We are primarily looking for a lack of autocorrelation, which would suggest our AR1 model is appropriate for the latent trend
```{r, fig.width=6, fig.height=6, fig.align='center'}
plot_mvgam_resids(lynx_mvgam, n_bins = 25)
```
